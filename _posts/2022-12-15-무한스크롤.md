---
title: "무한스크롤"
date: "2022-12-15 00:00:00"
categories: [FE, React]
tags: [react, scroll, infinite] # TAG는 반드시 소문자로 이루어져야함!
---

## 📌 리액트 무한스크롤(infinite scroll) 구현하기

### ✏️ 구현 방법

1. Scroll Event를 감지하고, 해당 이벤트 핸들러에서 스크롤값을 비교
2. Javascript에서 지원하는 Observer API를 활용

## 📌 Scroll Event를 감지하고, 해당 이벤트 핸들러에서 스크롤값을 비교

### ✏️ Scroll.tsx

```javascript
import axios from 'axios';
import { useRef, useState } from 'react';
import Loading from './common/Loading';
import useInfiniteScroll from './useInfiniteScroll';

export const Scroll = () => {
  console.log('scroll');
  const idx = useRef<number>(0);
  const [list, setList] = useState<object[]>([]);
  console.log(list);


  const fetchList = async () => {
    console.log('fetch');
    const addList = await axios.get(`http://localhost:3001/data${idx.current}`);
    console.log(list, addList.data);
    await setList([...list, addList.data]);
    idx.current++;
  };
  const { isEnd } = useInfiniteScroll({ onScrollEnd: fetchList });
  return (
    <div>
      {list.map((item, idx) => (
        <div key={idx}>
          <br />
          {item.toString()}
        </div>
      ))}
      {isEnd && <Loading />}
    </div>
  );
};

```

### ✏️ useinfiniteScroll.ts

```javascript
import { useEffect, useState, useCallback } from "react";

type OptionType = {
  onScrollEnd?: () => void,
};

type ReturnType = {
  isEnd: boolean,
};

const useInfiniteScroll = ({ onScrollEnd }: OptionType): ReturnType => {
  console.log("useinfi");
  const lockScroll = useCallback(() => {
    document.body.style.overflow = "hidden";
  }, []);

  const unlockScroll = useCallback(() => {
    document.body.style.overflow = "";
  }, []);

  const [isEnd, setIsEnd] = useState(false);

  const handleScroll = async () => {
    console.log("handleScroll");
    const scrollHeight = document.documentElement.scrollHeight;
    const scrollTop = document.documentElement.scrollTop;
    const clientHeight = document.documentElement.clientHeight;

    // console.log(scrollHeight, scrollTop, clientHeight);

    if (scrollTop + clientHeight >= scrollHeight) {
      setIsEnd(true);
      lockScroll();
      if (onScrollEnd) await onScrollEnd();
      await unlockScroll();
      await setIsEnd(false);
    }
  };

  useEffect(() => {
    console.log("mount");
    window.addEventListener("scroll", handleScroll);
    // console.log(window);
    return () => {
      console.log("cleanup");
      window.removeEventListener("scroll", handleScroll);
    };
  }, []);

  return { isEnd };
};

export default useInfiniteScroll;
```

handleScroll() 은 스크롤 이벤트에 대한 핸들러 함수이다. height 계산을 통해 스크롤이 끝나면 로직을 실행한다.
scrollHeight : 페이지의 총 높이이다. 이는, 화면에 보이지 않는 높이까지 고려된 높이다.
scrollTop : 이미 스크롤된 높이이다. 화면 상단이 기준이 된다.
clientHeight : 브라우저 화면, 즉 사용자에게 보여지는 높이이다.

### ✏️ jsonserver

data.json

```
{
  "data0": [1, 2, 3, 4],
  "data1": [5, 6, 7, 8],
  "data2": [9, 10, 11, 12],
  "data3": [13, 14, 15, 16]
}

```

### ✏️ 설명

스크롤이 바닥을 감지할때마다 fetch에서 데이터를 불러와 화면에 뿌려준다

![ezgif com-gif-maker](https://user-images.githubusercontent.com/45509511/207811462-064068e6-2498-4d18-89b1-87b72777fa3f.gif)

<img width="590" alt="스크린샷 2022-12-15 오후 5 20 49" src="https://user-images.githubusercontent.com/45509511/207810975-e35f7990-a833-49e2-880c-60e62ef8e7b1.png">

이렇게 하면 위의 사진처럼 스크롤 이벤트가 과다하게 발생되는데

lodash의 throttle을 이용해 컨트롤 가능하다.

```javascript
import { useEffect, useState, useCallback } from "react";
import { throttle } from "lodash";

type OptionType = {
  onScrollEnd?: () => void,
};

type ReturnType = {
  isEnd: boolean,
};

const useInfiniteScroll = ({ onScrollEnd }: OptionType): ReturnType => {
  console.log("useinfi");
  const lockScroll = useCallback(() => {
    document.body.style.overflow = "hidden";
  }, []);

  const unlockScroll = useCallback(() => {
    document.body.style.overflow = "";
  }, []);

  const [isEnd, setIsEnd] = useState(false);

  const handleScroll = throttle(async () => {
    console.log("handleScroll");
    const scrollHeight = document.documentElement.scrollHeight;
    const scrollTop = document.documentElement.scrollTop;
    const clientHeight = document.documentElement.clientHeight;

    // console.log(scrollHeight, scrollTop, clientHeight);

    if (scrollTop + clientHeight >= scrollHeight) {
      setIsEnd(true);
      lockScroll();
      if (onScrollEnd) await onScrollEnd();
      await unlockScroll();
      await setIsEnd(false);
    }
  }, 300);

  useEffect(() => {
    console.log("mount");
    window.addEventListener("scroll", handleScroll);
    // console.log(window);
    return () => {
      console.log("cleanup");
      window.removeEventListener("scroll", handleScroll);
    };
  }, []);

  return { isEnd };
};

export default useInfiniteScroll;
```

<img width="607" alt="스크린샷 2022-12-15 오후 5 26 37" src="https://user-images.githubusercontent.com/45509511/207811090-d136e050-b181-48c6-9247-50a8aed90de4.png">

시연시간 300ms를 주어 스크롤 이벤트 발생 횟수가 많이 줄은것을 확인할 수 있다.

## 📌 2. Javascript에서 지원하는 Observer API를 활용

### ✏️ Observer API

Observer pattern은 객체 상태변화를 관찰하는 관찰자들(옵저버)을 등록하여 상태변화가 있을 때마다 각 옵저버에 알리는 패턴이다.

이 논리에 기반한 Javascript 내장 API가 Observer API 인 것이다.

1. MutationObserver

DOM 변경을 감지하는 옵저버이다. 요소의 삽입, 수정, 삭제 및 자식요소가 수정되는 경우 등을 감지한다.

2. ResizeObserver

타겟 요소가 리사이징 이벤트를 통해 크기가 변경될 때를 감지하는 옵저버다. 반응형으로 보이는데 유용하다.

3. IntersectionObserver

타겟 요소와 상위 요소(혹은 최상위 document)의 viewport 사이에 교차지점을 비동기적으로 관찰한다.

타겟요소가 화면에 얼마나 보이는지에 따라 다양한 이벤트를 줄 수 있다.

### ✏️ 사용 방법

인스턴스 생성

```javascript
let observer = new IntersectionObserver(callback, options);
```

- callback : 교차시에 실행되는 함수이다. 로딩구현이나 패치 등의 함수가 통상 할당된다.
  - options : Intersection Observer에 관한 설정을 할 수 있는 부분이다.
  - root : 교차를 감지하는 root 요소. observe로 등록할 요소의 상위요소여야 한다. 기본값은 null(이 땐 브라우저 viewport)
  - rootMargin : root 요소의 마진값. 기본값은 0px.
  - threshold : 0.0 ~ 1.0 사이의 숫자들을 배열로 받는다. 이는 %로 치환되어, 해당 비율만큼 교차된 경우 콜백이 실행된다.

### ✏️ 참고

<a href='https://abangpa1ace.tistory.com/259'>https://abangpa1ace.tistory.com/259</a>
